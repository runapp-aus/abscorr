---
title: "Converting state names and abbreviations"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Converting state names and abbreviations}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(strayr)
```
## Converting state names and abbreviations

The `clean_state()` function makes it easy to wrangle vectors of State names and abbreviations - which might be in different forms and possibly
misspelled.

Let's start with a character vector that includes some misspelled State names,
some correctly spelled state names, as well as some abbreviations both malformed
and correctly formed.

```{r create-string}

x <- c("western Straya", "w. A ", "new soth wailes", "SA", "tazz", "Victoria",
       "northn territy")

```

To convert this character vector to a vector of abbreviations for State names,
 use `clean_state()`:

```{r state}
clean_state(x)

```

If you want full names for the states rather than abbreviations:

```{r state-fullnames}

clean_state(x, to = "state_name")

```

By default, `clean_state()` uses fuzzy or approximate string matching to match the 
elements in your character vector to state names/abbreviations. If you only want
to permit exact matching, you can disable fuzzy matching. This means you will 
never get false matches, but you will also fail to match misspelled state names 
or malformed abbreviations; you'll get an `NA` if no match can be found.

```{r state-exact}
 clean_state(x, fuzzy_match = FALSE)

```

If your data is in a data frame, `clean_state()` works well within a `dplyr::mutate()` call:

```{r dplyr}

 x_df <- data.frame(state = x, stringsAsFactors = FALSE)

library(dplyr)
 x_df %>% 
   mutate(state_abbr = clean_state(state))
```
